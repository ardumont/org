#+title: Functional programming principles in Scala
#+author: Antoine R. Dumont

* DONE Tools Setup for linux
CLOSED: [2013-07-22 Mon 09:09]
* DONE Tutorial working on the programming assignments
CLOSED: [2013-07-22 Mon 09:09]
* DONE Programming paradigms
CLOSED: [2013-07-22 Mon 09:09]
* DONE Elements of programming
CLOSED: [2013-07-22 Mon 09:09]
* DONE Evaluation strategies and termination
CLOSED: [2013-07-22 Mon 09:09]
Call By Name ->
Call By Value -> evaluate first the parameters

if CBV terminates then CBN terminates
Not true for the other way around

Scala defaults to CBV, you can force the evaluation strategy to CBN by adding =>
* DONE Conditionals and value definition
CLOSED: [2013-07-22 lun. 11:22]
** if-else
#+begin_src scala
def abs(x: Int) = if (x>=0) x else -x
#+end_src
** boolean expressions
#+begin_src scala
true
false
!b
b && b
b || b
e <= e
...
#+end_src

short-circuit evaluation (&& ||)
** value definitions
- def function definition by name
- val/var variable/form definition by value

Exemple:
#+begin_src scala
def x = loop
#+end_src

#+begin_src scala
val x = loop
#+end_src
ko, will never render the hand

** Exercise

By value:
#+begin_src scala
def and(x: Boolean, y: Boolean) = if x y else False
#+end_src

But, this =and(x, loop)= will break as scala is by value by default.

Redefining, by defining the y by name:

#+begin_src scala
def and(x: Boolean, y: => Boolean) = if x y else False
#+end_src

this will be ok and do not try to evaluate the loop expression.

* DONE Example square roots with Newton's method
CLOSED: [2013-07-22 lun. 12:00]
Successive approximations
- Start with an initial estimate y (y = 1 for starter)
- Repeatedly improve the estimate by taking the mean of y and x/y

#+begin_src scala
package coursera

import math.abs

object session {

  def sqrtIter(guess: Double, x: Double): Double =
    if (isGoodEnough(guess, x)) guess
    else sqrtIter(improve(guess, x), x)

  def isGoodEnough(guess: Double, x: Double) =
    abs(guess * guess - x) / x < 0.001

  def improve(guess: Double, x: Double) =
    (guess + x/guess) / 2

  def sqrt(x: Double) = sqrtIter(1.0, x)

  def main(args: Array[String]) = {
    val values = List(2.0, 4.0, 1e-6, 0.001, 0.1e-20, 1.0e20/*, 1.0e50*/)

    val squareValues = values.map(v => List(v, sqrt(v)))

    squareValues.foreach(println)
  }
}

// [info] Running coursera.session 4
// List(2.0, 1.4142156862745097)
// List(4.0, 2.0000000929222947)
// List(1.0E-6, 0.031260655525445276)
// List(0.001, 0.04124542607499115)
// List(1.0E-21, 0.03125)
// List(1.0E20, 1.0E10)
// sqrt(1.0E20): 1.0E10
// ^D^D  C-c C-c^C
// Process sbt exited abnormally with code 130
#+end_src

1. the =isGoodEnough= test is not very precise for small numbers and can lead to non-termination for very large numbers. Explain why.

- takes absolute difference
- small numbers: the threshold value 0.001 might be too huge
- large numbers: further apart than this absolute value (distance might be larger than the threshold)
- we can make test proportional to x


2. Design a different version of =isGoodEnough= that does not have these problems.

3. Test your version with some very very small and large numbers e.g.
0.001
0.1e-20
1.0e20
1.0e50

#+begin_src scala
package coursera

import math.abs

object session {

  def sqrtIter(guess: Double, x: Double): Double =
    if (isGoodEnough(guess, x)) guess
    else sqrtIter(improve(guess, x), x)

  def isGoodEnough(guess: Double, x: Double) =
    abs(guess * guess - x) / x < 0.001

  def improve(guess: Double, x: Double) =
    (guess + x/guess) / 2

  def sqrt(x: Double) = sqrtIter(1.0, x)

  def main(args: Array[String]) = {
    val values = List(2.0, 4.0, 1e-6, 0.001, 0.1e-20, 1.0e20, 1.0e50)

    val squareValues = values.map(v => List(v, sqrt(v)))

    squareValues.foreach(println)
  }
}

// [info] Running coursera.session
// List(2.0, 1.4142156862745097)
// List(4.0, 2.000609756097561)
// List(1.0E-6, 0.0010000001533016628)
// List(0.001, 0.03162278245070105)
// List(1.0E-21, 3.1633394544890125E-11)
// List(1.0E20, 1.0000021484861237E10)
// List(1.0E50, 1.0000003807575104E25)
// [success] Total time: 1 s, completed 22 juil. 2013 11:43:47
#+end_src

* DONE Blocks and lexical scope
CLOSED: [2013-07-22 lun. 12:22]
** nested functions
- split up task into many small functions
- avoid namespace pollution
- to do this in scala, put those private functions into the main function

For example, for the sqrt sample:
#+begin_src scala
package coursera

import math.abs

object session {

  def sqrt(x: Double) = {
    def sqrtIter(guess: Double, x: Double): Double =
      if (isGoodEnough(guess, x)) guess
      else sqrtIter(improve(guess, x), x)

    def isGoodEnough(guess: Double, x: Double) =
      abs(guess * guess - x) / x < 0.001

    def improve(guess: Double, x: Double) =
      (guess + x/guess) / 2

    sqrtIter(1.0, x)
  }

  def main(args: Array[String]) = {
    val values = List(2.0, 4.0, 1e-6, 0.001, 0.1e-20, 1.0e20, 1.0e50)

    val squareValues = values.map(v => List(v, sqrt(v)))

    squareValues.foreach(println)
  }
}

// [info] Running coursera.session
// List(2.0, 1.4142156862745097)
// List(4.0, 2.000609756097561)
// List(1.0E-6, 0.0010000001533016628)
// List(0.001, 0.03162278245070105)
// List(1.0E-21, 3.1633394544890125E-11)
// List(1.0E20, 1.0000021484861237E10)
// List(1.0E50, 1.0000003807575104E25)
// [success] Total time: 1 s, completed 22 juil. 2013 11:58:50
#+end_src

For this, we use a block.
** scope rules
Inside a block, as long as not shadowed, the function/variables defined are visibles inside nested blocks.

* DONE Tail recursion
CLOSED: [2013-07-22 lun. 14:57]
Application rewriting rule
substitution of all occurences of parameters by their corresponding values

Ex:

Tail recursion:
#+begin_src scala
  def gcd(a: Int, b: Int): Int =
    if (b == 0) a else gcd(b, a % b)
#+end_src

No tail recursion as there exists some operations to be done after the recursion call.
#+begin_src scala
  def factorial(n: Int): Int =
    if (n == 0) 1 else n * factorial (n-1)
#+end_src

Tail recursion -> if a function calls itself as its last action, the function's stack frame can be reused.

Define a tail-recursive version of the factorial
#+begin_src scala
...
  def factorial(n: Int): Int = {
    @tailrec
    def fact(n: Int, r: Int): Int =
      if (n == 0) r else fact(n-1, n*r)

    fact(n, 1)
  }
...
#+end_src

* DONE Higher-order functions
CLOSED: [2013-07-22 lun. 15:53]
** definition
- functions as first-class values:
  - functions can be passed as parameters to function
  - functions can be returned as result of function
- functions that takes functions as parameters are called Higher-order functions.

Provides flexible way to compose programs
** Examples
#+begin_src scala
package coursera

object w3 {
  // sum of the integers between a and b
  def sumInts(a: Int, b: Int): Int =
    if(a > b) 0 else a + sumInts(a + 1, b)

  def sumCubes(a: Int, b: Int) :Int = {
    def cube(a: Int): Int = a * a * a

    def sum(a: Int, b: Int): Int =
      if(a > b) 0 else cube(a) + sum(a + 1, b)

    sum(a, b)
  }

  def sumFactorials(a: Int, b: Int): Int =
    if(a > b) 0 else w2.factorial(a) + sumFactorials(a + 1, b)

  def main(args: Array[String]) = {
    println(sumInts(1, 10))
    println(sumCubes(1, 10))
    println(sumFactorials(1, 10))
  }
}

// [info] Running coursera.w3
// 55
// 3025
// 4037913
// [success] Total time: 0 s, completed 22 juil. 2013 15:08:24
#+end_src

** Factor out common patterns?

#+begin_src scala
package coursera

object w3 {
  def sum(a: Int, b: Int, fn: Int => Int): Int =
    if(a > b) 0 else fn(a) + sum(a + 1, b, fn)

  // sum of the integers between a and b
  def sumInts(a: Int, b: Int): Int =
    sum(a, b, identity)

  def sumCubes(a: Int, b: Int) :Int = {
    def cube(a: Int): Int = a * a * a

    sum(a, b, cube)
  }

  def sumFactorials(a: Int, b: Int): Int =
    sum(a, b, w2.factorial)

  def main(args: Array[String]) = {
    val values = List(Tuple2(1, 10),
                      Tuple2(10, 20))

    val functions : Map[String, (Int, Int) => Int] =
      Map("sumInts"       -> sumInts,
          "sumCubes"      -> sumCubes,
          "sumFactorials" -> sumFactorials)

    def displayResult(fnName: String, a: Int, b: Int, r: Int): String =
      fnName + "(" + a + ", " + b + ") = " + r

    functions.foreach { case (fnName, fn) =>
      (for ((a, b) <- values)
         println(displayResult(fnName, a, b, fn(a, b))))
    }

    w2.title("end")
  }
}

// [info] Running coursera.w3
// sumInts(1, 10) = 55
// sumInts(10, 20) = 165
// sumCubes(1, 10) = 3025
// sumCubes(10, 20) = 42075
// sumFactorials(1, 10) = 4037913
// sumFactorials(10, 20) = 267631616

// ######### end

// [success] Total time: 2 s, completed 22 juil. 2013 15:38:09
#+end_src


** Anonymous function
syntactic sugar

We can for example avoid 'def'ining the `cube` version:
#+begin_src scala
  def sumCubes(a: Int, b: Int) :Int =
    sum(a, b, (x: Int) => x * x * x)
#+end_src

We can also let the compiler infer the type
#+begin_src scala
  def sumCubes(a: Int, b: Int) :Int =
    sum(a, b, x => x * x * x)
#+end_src

** define the tail recursive version of the sum function

#+begin_src scala
  def sum(a: Int, b: Int, fn: Int => Int): Int = {

    @tailrec
    def sumTR(x: Int, r: Int): Int =
      if(x > b) r else sumTR(x + 1, fn(x) + r)

    sumTR(a, 0)
  }

#+end_src

* DONE Currying
CLOSED: [2013-07-22 lun. 18:24]

** Can we remove the redundant bounds parameters?
Yes

by redefining the `sum` function to return another function which takes the 2 bounds parameters:
#+begin_src scala
  def sum(fn: Int => Int): (Int, Int) => Int = {

    @tailrec
    def sumTR(a: Int, b: Int, r: Int): Int =
      if(a > b) r else sumTR(a + 1, b, fn(a) + r)

    (a, b) => sumTR(a, b, 0)
  }
#+end_src

Thus, this simplifies the definition of the functions that rely on `sum`:
#+begin_src scala
  def sumInts = sum(identity)
  def sumCubes = sum(x => x * x * x)
  def sumFactorials = sum(w2.factorial)
#+end_src

Complete package:
#+begin_src scala
package coursera

import scala.annotation.tailrec

object w3 {
  def sum(fn: Int => Int): (Int, Int) => Int = {

    @tailrec
    def sumTR(a: Int, b: Int, r: Int): Int =
      if(a > b) r else sumTR(a + 1, b, fn(a) + r)

    (a, b) => sumTR(a, b, 0)
  }

  // sum of the integers between a and b
  def sumInts = sum(identity)

  def sumCubes = sum(x => x * x * x)

  def sumFactorials = sum(w2.factorial)

  def main(args: Array[String]) = {
    val values = List(Tuple2(1, 10),
                      Tuple2(10, 20))

    val functions : Map[String, (Int, Int) => Int] =
      Map("sumInts"       -> sumInts,
          "sumCubes"      -> sumCubes,
          "sumFactorials" -> sumFactorials)

    def displayResult(fnName: String, a: Int, b: Int, r: Int): String =
      fnName + "(" + a + ", " + b + ") = " + r

    functions.foreach { case (fnName, fn) =>
      (for ((a, b) <- values)
         println(displayResult(fnName, a, b, fn(a, b))))
    }

    w2.title("end")
  }
}

// [info] Running coursera.w3
// sumInts(1, 10) = 55
// sumInts(10, 20) = 165
// sumCubes(1, 10) = 3025
// sumCubes(10, 20) = 42075
// sumFactorials(1, 10) = 4037913
// sumFactorials(10, 20) = 267631616

// ######### end

// [success] Total time: 1 s, completed 22 juil. 2013 16:04:58
#+end_src

** Can we remove the middlemen function?
Yes!

#+begin_src scala
package coursera

import scala.annotation.tailrec

object w3 {
  def sum(fn: Int => Int): (Int, Int) => Int = {

    @tailrec
    def sumTR(a: Int, b: Int, r: Int): Int =
      if(a > b) r else sumTR(a + 1, b, fn(a) + r)

    (a, b) => sumTR(a, b, 0)
  }

  def main(args: Array[String]) = {
    val values = List(Tuple2(1, 10),
                      Tuple2(10, 20))

    val functions : Map[String, (Int, Int) => Int] =
      Map("sumInts"       -> sum(identity),
          "sumCubes"      -> sum(x => x * x * x),
          "sumFactorials" -> sum(w2.factorial))

    def displayResult(fnName: String, a: Int, b: Int, r: Int): String =
      fnName + "(" + a + ", " + b + ") = " + r

    functions.foreach { case (fnName, fn) =>
      (for ((a, b) <- values)
         println(displayResult(fnName, a, b, fn(a, b))))
    }

    w2.title("end")
  }
}

// [info] Running coursera.w3
// sumInts(1, 10) = 55
// sumInts(10, 20) = 165
// sumCubes(1, 10) = 3025
// sumCubes(10, 20) = 42075
// sumFactorials(1, 10) = 4037913
// sumFactorials(10, 20) = 267631616

// ######### end

// [success] Total time: 0 s, completed 22 juil. 2013 16:10:28
#+end_src

** Simplification over the definition of function that returns function
#+begin_src scala
  def sum(fn: Int => Int) (a: Int, b: Int): Int = {

    @tailrec
    def sumTR(a: Int, r: Int): Int =
      if(a > b) r else sumTR(a + 1, fn(a) + r)

    sumTR(a, 0)
  }
#+end_src

** Exercises
1. Write a product function `pdt` that calculates the product of the values of a function for the points on a given interval

#+begin_src scala
  def pdt(fn: Int => Int) (a: Int, b: Int): Int = {
    @tailrec
    def loop(a: Int, r: Int): Int =
      if(a > b) r else loop(a + 1, fn(a) * r)

    loop(a, 1)
  }
#+end_src

2. Write factorial in terms of `pdt`

#+begin_src scala
  def factorial(n: Int) = pdt(identity)(1, n)
#+end_src

3. Can you write a more general function, which generalizes both `sum` and `pdt`?

#+begin_src scala
package coursera

import scala.annotation.tailrec

object w3 {
  def fold(fn: Int => Int, op: (Int, Int) => Int, initial: Int)(a: Int, b: Int): Int = {
    @tailrec
    def loop(a: Int, r: Int): Int =
      if(a > b) r else loop(a + 1, op(fn(a), r))

    loop(a, initial)
  }

  def sum(fn: Int => Int) (a: Int, b: Int): Int = fold(fn, (x, y) => x + y, 0)(a, b)
  def pdt(fn: Int => Int) (a: Int, b: Int): Int = fold(fn, (x, y) => x * y, 1)(a, b)

  def factorial(n: Int) = pdt(identity)(1, n)

  def main(args: Array[String]) = {
    w2.title("sum of a function values (cube, factorial, etc...)")

    val values = List(Tuple2(1, 10),
                      Tuple2(10, 20))

    val functions : Map[String, (Int, Int) => Int] =
      Map("sumInts"       -> sum(identity),
          "sumCubes"      -> sum(x => x * x * x),
          "sumFactorials" -> sum(factorial))

    def displayResult(fnName: String, a: Int, b: Int, r: Int): String =
      fnName + "(" + a + ", " + b + ") = " + r

    functions.foreach { case (fnName, fn) =>
      (for ((a, b) <- values)
         println(displayResult(fnName, a, b, fn(a, b))))
    }

    w2.title("factorial")

    val fvalues = List(1,2,3,4,5,6,7,8,9)

    fvalues.map(factorial).map(println)

    w2.title("end")
  }
}

// ######### sum of a function values (cube, factorial, etc...)

// sumInts(1, 10) = 55
// sumInts(10, 20) = 165
// sumCubes(1, 10) = 3025
// sumCubes(10, 20) = 42075
// sumFactorials(1, 10) = 4037913
// sumFactorials(10, 20) = 267631616

// ######### factorial

// 1
// 2
// 6
// 24
// 120
// 720
// 5040
// 40320
// 362880

// ######### end

// [success] Total time: 1 s, completed 22 juil. 2013 18:19:56
#+end_src

* DONE Example finding fixed points
CLOSED: [2013-07-23 mar. 08:47]
a number x is called a fixed point of a function if f(x) = x

for some functions f, we can locate the fixed points by starting with an initial estimate and then by applying f in a repetitive way: iterate f x

until the value does not vary anymore (or the changes is sufficiently small)
#+begin_src scala
package coursera

import math.abs

object w32 {
  val tolerance = 0.0001

  def isCloseEnough(x: Double, y: Double): Boolean =
    abs((x - y) / x) / x < tolerance

  def fixedPoint(f: Double => Double) (firstGuess: Double) = {
    def iterate(guess: Double): Double = {
      val next = averageDamp(f)(guess)
      if(isCloseEnough(guess, next)) next else iterate(next)
    }
    iterate(firstGuess)
  }

  def averageDamp(f: Double => Double)(x: Double) :Double =
    (x + f(x)) / 2

  def main(args: Array[String]) = {
    println(fixedPoint(x => 1 + x/2)(1))
  }
}

// [info] Running coursera.w32
// 1.999755859375
// [success] Total time: 3 s, completed 22 juil. 2013 18:44:11
#+end_src

Revisiting the square root:

#+begin_src scala
package coursera

import math.abs

object w1 {

  def sqrt(x: Double) = w32.fixedPoint(y => x/y)(1.0)

  def main(args: Array[String]) = {
    val values = List(2.0, 4.0, 1e-6, 0.001, 0.1e-20, 1.0e20, 1.0e50)

    val squareValues = values.map(v => List(v, sqrt(v)))

    squareValues.foreach(println)
  }
}

// [info] Running coursera.w1
// List(2.0, 1.4142135623746899)
// List(4.0, 2.000000000000002)
// List(1.0E-6, 0.001)
// List(0.001, 0.03162277660168433)
// List(1.0E-21, 3.162277660168379E-11)
// List(1.0E20, 2.5E19)
// List(1.0E50, 2.5E49)
// [success] Total time: 2 s, completed 22 juil. 2013 18:52:31

#+end_src

* DONE Scala syntax summary
CLOSED: [2013-07-23 mar. 09:14]
Review the language constructs we have seen so far
** Language elements seen so far
Context-free syntax in Extended Backus-Naur form (EBNF)

Syntax:
| alternative
[...] option (0 or 1)
{...} repetition (0 or more)

** Types

#+begin_src grammar
Type         = SimpleType | FunctionType
FunctionType = SimpleType '=>' Type
            | '(' [Types] ')' ' =>' Type
SimpleType  = Ident
Types       = Type {',' Type}
#+end_src

type:
- numeric type: Int, Double, Byte, Short, Char, Long, Float
- Boolean
- String

function type example: Int => Int, (Int, Int) => Int


** Expressions
#+begin_src grammar
Expr         = InfixExpr | FunctionExpr | if '(' Expr ')' Expr else Expr
InfixExpr    = PrefixExpr | InfixExpr Operator InfixExpr
Operator     = Ident
PrefixExpr   = ['+' | '-' | '!' | '~'] SimpleExpr
SimpleExpr   = Ident | literal | SimpleExpr '.' ident | Block
FunctionExpr = Bindings '=>' Expr
Bindings     = ident [':' SimpleType] | '(' [Binding {',' Binding}] ')'
Binding      = ident [':' Type]
Block        = '{' {Def ';'}' Expr '}'
#+end_src

expression examples:
|------------------------+--------------------------------|
| identifier             | isGoodEnough                   |
| literal                | 0, 1.0, "abc"                  |
| function application   | sqrt(x)                        |
| operator application   | -x, y + x                      |
| selection              | math.abs                       |
| conditional expression | if (x < 0) -x else x           |
| block                  | { val x = math.abs(y); x * 2 } |
| anonymous function     | x => x + 1                     |
|------------------------+--------------------------------|

** TODO Definitions

#+begin_src grammar
Def        = FunDef | ValDef
FunDef     = def ident { '(' [Parameters] ')' } [':' Type] '=' Expr
ValDef     = val ident [':' Type] '=' Expr
Parameter  = ident ':' [ '=>' ] Type
Parameters = Parameter {',' Parameter }
#+end_src

a definition can be:
- a function definition:
#+begin_src scala
def square(x: Int) = x * x
#+end_src
- a value definition:
#+begin_src scala
val y = square(2)
#+end_src

a parameter can be:
- a CBV parameter: =(x: Int)=
- a CBN parameter: =(x: => Int)=

* DONE Functions and data
CLOSED: [2013-07-23 mar. 10:12]
We've seen functions so far, first-class functions, HOF, currying, etc...

data: introducing objects and classes... WTF!!!

** functions create and encapsulate data structure
Example:
Rational Numbers.

Problematic: Design a package for doing rational arithmetic.

Definition: A rational number is defined such as: \( \frac{x}{y}, x,y âˆˆ \mathbf{N}^2 \)
x is the numerator, y is the denominator

** Rational addition
Odersky's Claim:
- difficult to manage the parameters numerator, denominator for each function definition
- better choice to combine the numerator and denominator in a data structure (by this he means class!!!)

** Classes
#+begin_src scala
class Rational(x: Int, y: Int) {
  def numer = x
  def denom = y
}
#+end_src

introduces:
- a new type Rational
- a constructor Rational to create elements of this type

Separation in namespaces between names of types and values (so no conflict between the type and the constructor)

** Objects
Objects: elements of a class type

Creation: using the keyword `new`

#+begin_src scala
new Rational(1, 2)
#+end_src


** Implementing

Using a function addRational:
#+begin_src scala
package coursera

class Rational(x: Int, y: Int) {
  def numer = x
  def denom = y

  def addRational(r: Rational, s: Rational): Rational =
    new Rational(r.numer * s.denom + s.numer * r.denom, r.denom * s.denom)

  def makeString(r: Rational): String = r.numer + "/" + r.denom

  override def toString(): String = makeString(this)
}

object Rational {
  def main(args: Array[String]) = {
    val r0 = new Rational(1, 2)
    val r1 = new Rational(2, 3)

    println(r0.addRational(r0, r1))
  }
}

// [info] Running coursera.Rational
// 7/6
// [success] Total time: 2 s, completed 23 juil. 2013 09:46:35
#+end_src

Defining a method in the Rational class:

#+begin_src scala
package coursera

class Rational(x: Int, y: Int) {
  def numer = x
  def denom = y

  def add(r: Rational): Rational =
    new Rational(r.numer * denom + numer * r.denom, r.denom * denom)

  override def toString(): String = numer + "/" + denom
}

object Rational {
  def main(args: Array[String]) = {
    val r0 = new Rational(1, 2)
    val r1 = new Rational(2, 3)

    println(r0.add(r1))
  }
}

// [info] Running coursera.Rational
// 7/6
// [success] Total time: 2 s, completed 23 juil. 2013 09:52:37
#+end_src

** Exercises
1. add a method neg to class Rational used like this: x.neg
#+begin_src scala
  def neg(): Rational = new Rational(-numer, denom)
#+end_src

2. Add a method sub to substract two rational numbers
#+begin_src scala
  def sub(r: Rational): Rational = add(r.neg)
#+end_src

3. With the values of x, y, z as given in the previous slide, what is the result of =x - y - z= ?

#+begin_src scala
    println(x.sub(y).sub(z))
#+end_src

-79/4
* DONE More fun with rationals
CLOSED: [2013-07-23 mar. 11:06]
Rational are not in their simple form, here is the adaptation code:
#+begin_src scala
package coursera

import scala.annotation.tailrec

class Rational(x: Int, y: Int) {
  private val g = w2.gcd(x, y)

  def numer = x / g
  def denom = y / g

  def add(r: Rational): Rational =
    new Rational(r.numer * denom + numer * r.denom, r.denom * denom)

  def neg(): Rational = new Rational(-numer, denom)

  def sub(r: Rational): Rational = add(r.neg)

  override def toString(): String = numer + "/" + denom
}

object Rational {
  def main(args: Array[String]) = {
    val x = new Rational(1, 3)
    val y = new Rational(5, 7)
    val z = new Rational(3, 2)

    println(x.add(y))
    println(y.neg)
    println(x.sub(x))
    println(x.sub(y).sub(z))
    println(y.add(y))
  }
}

// [info] Running coursera.Rational
// 22/21
// 5/-7
// 0/1
// -79/42
// 10/7
// [success] Total time: 1 s, completed 23 juil. 2013 10:23:26
#+end_src

** private member or method
Private member or methods are defined using the `private` keyword.

** Requirement
Requirement are tests runned at class construction time, e.g:
#+begin_src scala
class Rational(x: Int, y: Int) {
  require(y != 0, "denominator must be non zero")
...
#+end_src

If requirement is not respected, this will throw an IllegalArgumentException with the message setuped:
#+begin_src scala
[error] (run-main) java.lang.IllegalArgumentException: requirement failed: denominator must be non zero
java.lang.IllegalArgumentException: requirement failed: denominator must be non zero
	at scala.Predef$.require(Predef.scala:214)
	at coursera.Rational.<init>(Rational.scala:6)
	at coursera.Rational$.main(Rational.scala:42)
	at coursera.Rational.main(Rational.scala)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
[trace] Stack trace suppressed: run last compile:run for the full output.
java.lang.RuntimeException: Nonzero exit code: 1
	at scala.sys.package$.error(package.scala:27)
[trace] Stack trace suppressed: run last compile:run for the full output.
[error] (compile:run) Nonzero exit code: 1
#+end_src

Require is used to enforce a precondition on the caller of a function.

To sum up, if a requirement fails, it's not the function/method's fault, there has been a problem when calling the function/method.

** Assertions
assert is used to check the code of the function itself.
If not respected, this will throw AssertionError.

Example:
#+begin_src scala
val x = sqrt(y)
assert(x >= 0)
#+end_src

To sum up, if an assertion fails, it's not the caller's fault. There has been trouble in the function/method itself.

** Constructor
a class implicitely introduces a constructor. This one is called the primary constructor.
it:
- takes the parameters of the class
- executes all statements in the class body (require, form assigment, etc...)
** Multiple constructor possible
We can extend the class by adding other constructors:
For example:
#+begin_src scala
class Rational(x: Int, y: Int) {
  require(y != 0, "denominator must be non zero")

  def this(x: Int) = this(x, 1)
...
#+end_src

Thus the calling:
#+begin_src scala
    val a = new Rational(2)
    println(a)
#+end_src

renders:
#+begin_src scala
2/1
#+end_src
** Exercise
Modify the rational class so that rational numbers are kept unsimplified internally, but the simplification is applied when numbers are converted to strings.
#+begin_src scala
  override def toString(): String = {
    val g = w2.gcd(numer, denom)
    numer / g + "/" + denom / g
  }

#+end_src

* DONE Evaluation and operators
CLOSED: [2013-07-23 mar. 11:37]

** Classes and substitutions
- Instantiation of the class new C(e_1, ..., e_m) is evaluated like the arguments of a normal function.
- new C(e_1, ..., e_m).f(w_1, ..., w_n) Instantiation?
3 substitutions:
  - first the formal parameters w_1, ..., w_n of the function are replaced by the arguments w_1, etc...
  - second the parameters of the constructor
  - lastly the eventual 'this' is replaced by the instance (value) of the class in the body definition

** Operators

- infix notation: any method with a parameter can be used like an infix operator
#+begin_src scala

object Rational {
  def main(args: Array[String]) = {
    val x = new Rational(1, 3)
    val y = new Rational(5, 7)
    val z = new Rational(3, 2)

    println(x add y)
    println(y neg)
    println(x sub x)
    println(x sub y sub z)
    println(y add y)
    println(x less y)
    println(y less x)
    println(x max y)
    println(y max x)

    val a = new Rational(2)
    println(a)
  }
}

// [info] Running coursera.Rational
// 22/21
// 5/-7
// 0/1
// -79/42
// 10/7
// true
// false
// 5/7
// 5/7
// 2/1
// [success] Total time: 0 s, completed 23 juil. 2013 11:20:56
#+end_src

- Operators can be used as identifiers
  - alphanum
  - symbolic (starting with an operator symbol, followed by other operator symbols)
  - _ counts as a letter
  - alphanumeric identifiers can also end in an underscore followed by some operator symbols
Examples:
#+begin_src scala
x1
*,
+?%&,
vector_++
counter_=
#+end_src

Simplifying the Rational class:
#+begin_src scala
package coursera

import scala.annotation.tailrec

class Rational(x: Int, y: Int) {
  require(y != 0, "denominator must be non zero")

  def this(x: Int) = this(x, 1)

  val numer = x
  val denom = y

  def +(r: Rational): Rational =
    new Rational(r.numer * denom + numer * r.denom, r.denom * denom)

  def unary_-(): Rational = new Rational(-numer, denom)

  def -(r: Rational): Rational = this + -r

  def < (r: Rational): Boolean = numer * r.denom < r.numer * denom

  def max(r: Rational): Rational = if (this < r) r else this

  override def toString(): String = {
    val g = w2.gcd(numer, denom)
    numer / g + "/" + denom / g
  }
}

object Rational {
  def main(args: Array[String]) = {
    val x = new Rational(1, 3)
    val y = new Rational(5, 7)
    val z = new Rational(3, 2)

    println(x + y)
    println(-y)
    println(x + x)
    println(x - y - z)
    println(y + y)
    println(x < y)
    println(y < x)
    println(x max y)
    println(y max x)

    val a = new Rational(2)
    println(a)
  }
}

// [info] Running coursera.Rational
// 22/21
// 5/-7
// 2/3
// -79/42
// 10/7
// true
// false
// 5/7
// 5/7
// 2/1
// [success] Total time: 1 s, completed 23 juil. 2013 11:30:15
#+end_src


** Precedence rules
determined by its first character.
following table lists the characters in increasing order of priority precedence:

|--------------------------------|
| (all letters)                  |
| pipe \                         |
| ^                              |
| &                              |
| < >                            |
| \= !                           |
| :                              |
| + -                            |
| * / %                          |
| (all other special characters) |
|--------------------------------|

** Exercise
Provide a fully parenthesized version of:
a + b ^? c ?^ d less a ==> b | c
(binary operation be put in parentheses)

((a + b) ^? (c ?^ d)) less ((a ==> b) | c)

* DONE Class hierarchies
CLOSED: [2013-07-23 mar. 12:37]

** Abstract classes
- can contain members which are missing an implementation
#+begin_src scala
abstract class IntSet {
  def incl(x: Int): IntSet
  def contains(x: Int): Boolean
}
#+end_src
- consequently no instances of an abstract class can be created with the operator new.

** IntSets
Implementing sets as binary trees:

#+begin_src scala
package coursera

abstract class IntSet {
  /**
    * to include an element in the set
    */
  def incl(x: Int): IntSet
  /**
    * is the element contains in the set
    */
  def contains(x: Int): Boolean
}

class Empty extends IntSet {
  def contains(x: Int): Boolean = false
  def incl(x: Int): IntSet = new Leaf(x, new Empty, new Empty)

  override def toString = "."
}

class Leaf(elem: Int, l: IntSet, r: IntSet) extends IntSet {

  def contains(x: Int): Boolean =
    if      (x < elem) l contains x
    else if (elem < x) r contains x
    else true

  def incl(x: Int): IntSet =
    if      (x < elem) new Leaf(elem, l incl x, r)
    else if (elem < x) new Leaf(elem, l,        r incl x)
    else this

  override def toString = "{" + l + elem + r + "}"
}

object IntSet {
  def main(args: Array[String]) = {
    val t1 = new Leaf(7,
                      new Leaf(5, new Empty, new Empty),
                      new Leaf(8, new Empty, new Empty))

    println(t1)
  }
}

// [info] Running coursera.IntSet
// {{.5.}7{.8.}}
// [success] Total time: 1 s, completed 23 juil. 2013 12:01:16

#+end_src

persistent data structure


** Base classes and subclasses

- IntSet -> superclass Empty and Leaf
- Empty, Leaf -> subclasses of IntSet
- no superclass is given, the standard java.lang.Object java class is assumed
- direct or indirect superclasses are called base classes
- base classes of Empty and Leaf are Object and IntSet
** Implementations and Overriding

singleton
#+begin_src scala
package coursera

abstract class IntSet {
  /**
    * to include an element in the set
    */
  def incl(x: Int): IntSet
  /**
    * is the element contains in the set
    */
  def contains(x: Int): Boolean
}

object Empty extends IntSet {
  def contains(x: Int): Boolean = false
  def incl(x: Int): IntSet = new Leaf(x, Empty, Empty)

  override def toString = "."
}

class Leaf(elem: Int, l: IntSet, r: IntSet) extends IntSet {

  def contains(x: Int): Boolean =
    if      (x < elem) l contains x
    else if (elem < x) r contains x
    else true

  def incl(x: Int): IntSet =
    if      (x < elem) new Leaf(elem, l incl x, r)
    else if (elem < x) new Leaf(elem, l,        r incl x)
    else this

  override def toString = "{" + l + elem + r + "}"
}

object IntSet {
  def main(args: Array[String]) = {
    val t1 = new Leaf(7,
                      new Leaf(5, Empty, Empty),
                      new Leaf(8, Empty, Empty))

    println(t1)
  }
}

// [info] Running coursera.IntSet
// {{.5.}7{.8.}}
// [success] Total time: 4 s, completed 23 juil. 2013 12:13:08

#+end_src
** Exercise
Write a method union for forming the union of two sets. You should implement the following abstract class
#+begin_src scala
abstract class IntSet {
  def incl(x: Int): IntSet
  def contains(x: Int): Boolean
  def union(other: IntSet): IntSet
}
#+end_src

solution:
#+begin_src scala
package coursera

abstract class IntSet {
  /**
    * to include an element in the set
    */
  def incl(x: Int): IntSet
  /**
    * is the element contains in the set
    */
  def contains(x: Int): Boolean
  /**
    * Union of 2 sets
    */
  def union(other: IntSet): IntSet
}

object Empty extends IntSet {
  def contains(x: Int): Boolean = false
  def incl(x: Int): IntSet = new Leaf(x, Empty, Empty)
  def union(other: IntSet): IntSet = other
  override def toString = "."
}

class Leaf(elem: Int, l: IntSet, r: IntSet) extends IntSet {

  def contains(x: Int): Boolean =
    if      (x < elem) l contains x
    else if (elem < x) r contains x
    else true

  def incl(x: Int): IntSet =
    if      (x < elem) new Leaf(elem, l incl x, r)
    else if (elem < x) new Leaf(elem, l,        r incl x)
    else this

  def union(other: IntSet): IntSet =
    ((l union r) union other) incl elem

  override def toString = "{" + l + elem + r + "}"
}

object IntSet {
  def main(args: Array[String]) = {
    val t1 = new Leaf(7,
                      new Leaf(5, Empty, Empty),
                      new Leaf(8, Empty, Empty))

    println(t1)
    println(t1 union t1)

    val t2 = new Leaf(12,
                      new Leaf(5, Empty, Empty),
                      Empty)

    println(t1 union t2)
  }
}

// [info] Running coursera.IntSet
// {{.5.}7{.8.}}
// {{.5.}7{.8.}}
// {{.5{{.7.}8.}}12.}
// [success] Total time: 3 s, completed 23 juil. 2013 12:31:03

#+end_src

* DONE How classes are organized
CLOSED: [2013-07-23 mar. 14:24]
** Packages
Classes and objects are organized in packages
To place a class or object inside a package, use a package clause at the top of your source file
#+begin_src scala
package progfun.examples
object Hello {...}
#+end_src

Fully qualified name: progfun.examples.Hello
#+begin_src sh
scala progfun.examples.Hello
#+end_src

** Import clauses

#+begin_src scala
import week3.Rational           // named import
import week3.{Rational, Hello}  // named import
import week3._                  // wildcard import
#+end_src

Import from either a package or an object.
** Automatic import
- package scala
- package java.lang
- all members of the singleton object scala.Predef.
- FQN:
  - scala.Int
  - scala.Boolean
  - java.lang.Object
  - scala.Predef.require
  - scala.Predef.assert
** scaladoc
http://www.scala-lang.org/api/current/index.html#package

** Traits
- scala, java -> one superclass (single inheritance)
- what if class has multiple natural supertypes?
=> here comes traits, declared like abstract class

#+begin_src scala
trait Planar {
  def height: Int
  def width: Int
  def surface = height * width
}
#+end_src

Classes, objects can inherit from at most one class
but can inherit from many Traits

#+begin_src scala
class Square extends Shape with Planar
                           with Movable...
#+end_src

java interface <<~ trait
trait can contain:
- fields
- concrete methods
** scala's class hierarchy
[[./scala-class-hierarchy.png]]

** Top Types
|--------+-------------------------------------|
| Type   | Description                         |
|--------+-------------------------------------|
| Any    | base type of all types              |
|        | \==, !=, equals, hashCode, toString |
|--------+-------------------------------------|
| AnyRef | base type of all reference Types    |
|        | alias of java.lang.Object           |
|--------+-------------------------------------|
| AnyVal | base type of all primitive Types    |
|--------+-------------------------------------|

** Nothing
- subtype of every other type
- no value of type Nothing
- to signal abnormal termination
- element type of empty collection
** Exceptions
same as java
#+begin_src scala
throw Exc
#+end_src

** null
- Every reference class type also has null as a value
- Null is a subtype of every class that inherits from Object; it is incompatible with subtypes of AnyVal

** Exercise
What is the type of =if (true) 1 else false=? AnyVal

* DONE Polymorphism
CLOSED: [2013-07-23 mar. 15:19]

** Cons-Lists
immutable linked-list formed of 2 blocks:
- Nil - the empty list
- Cons - a cell containing and element and the remainder of the list (pointer)

Examples:
List(1, 2, 3)
List(List(true, false), List(3))
** Cons-Lists in Scala

Beginning:
#+begin_src scala
trait IntList {}
class Nil extends IntList {}
class Cons(val head: Int, val tail: IntList) extends IntList {}
#+end_src

This will do but for each primitive type, we'd need to declare it again and again.
Instead, we will use generic type:
#+begin_src scala
trait List[T] {}
class Nil[T] extends List[T] {}
class Cons[T](val head: T, val tail: List[T]) extends List[T] {}
#+end_src

Implementation:
#+begin_src scala
package coursera

trait List[T] {
  def isEmpty: Boolean
  def head: T
  def tail: List[T]
}

class Nil[T] extends List[T] {
  def isEmpty = true
  def head = throw new NoSuchElementException("Nil.head")
  def tail = throw new NoSuchElementException("Nil.tail")
}

class Cons[T](val head: T, val tail: List[T]) extends List[T] {
  def isEmpty = false
}
#+end_src

** Polymorphism
a function type comes "in many forms".
In programming:
- function can be applied to arguments of many Types
- the type can have instances of many types

2 principals forms of Polymorphism:
- Subtyping: instances of a subclass can be passed to a base class
- generics: instances of a function or class are created by type parameterization
** Exercise

Write a function nth that takes an integer n and a list and selects the nth elements of the lists.
Elements are numbered from 0.
If index is outside the range from 0 up to the length of the list minus one, an IndexOutOfBoundsException should be thrown.

#+begin_src scala
package coursera

trait List[T] {
  def isEmpty: Boolean
  def head: T
  def tail: List[T]

  def toString: String
}

class Nil[T] extends List[T] {
  def isEmpty: Boolean = true
  def head: Nothing = throw new NoSuchElementException("Nil.head")
  def tail: Nothing = throw new NoSuchElementException("Nil.tail")

  override def toString: String = "."
}

class Cons[T](val head: T, val tail: List[T]) extends List[T] {
  def isEmpty: Boolean = false

  override def toString: String = "(" + head + ", " + tail.toString + ")"
}

object ConsListSession {
  def main(args: Array[String]) = {
    def singleton[T](elem: T) = new Cons[T](elem, new Nil[T])

    def nth[T](n: Int, l: List[T]): T =
      if (n < 0 || l.isEmpty) throw new IndexOutOfBoundsException("Out of range")
      else if (n == 0) l.head
      else nth(n-1, l.tail)

    def catchAndPrint[T](index: Int, l: List[T]) =
      try {
        nth(index, l)
      } catch {
        case e: IndexOutOfBoundsException => println("exception caught as expected: " + e)
      }

    println(singleton[Int](1))
    println(singleton[Boolean](true))

    val listTypes = new Cons[Int](1, new Cons[Int](2, new Nil[Int]))
    println(listTypes)

    println(nth(0, listTypes))
    println(nth(1, listTypes))

    catchAndPrint[Int](-1, listTypes)
    catchAndPrint[Int](3, listTypes)

    println("end")
  }
}

// [info] Running coursera.ConsListSession
// (1, .)
// (true, .)
// (1, (2, .))
// 1
// 2
// exception caught as expected: java.lang.IndexOutOfBoundsException: Out of range
// exception caught as expected: java.lang.IndexOutOfBoundsException: Out of range
// end
// [success] Total time: 2 s, completed 23 juil. 2013 15:15:15

#+end_src

* DONE More functions on lists
CLOSED: [2013-07-23 mar. 16:32]

** Standard
|-----------+-------------------------------------------|
| xs.length | length of the list                        |
| xs.last   | last element of the list                  |
| xs.init   | all elements except the last one          |
| xs take n | first n elements of the list              |
| xs drop n | xs minus the first n elements of the list |
| xs(n)     | xs !! n                                   |
|-----------+-------------------------------------------|

** Creating new list

|-------------------+----------------------------------------------------------------|
| xs ++ ys          | new list consisting of xs elements followed by the ys elements |
| xs.reverse        | reverse the current xs list                                    |
| xs updated (n, x) | update the nth element in xs with x                            |
|-------------------+----------------------------------------------------------------|

** Finding elements

|---------------+---------------------------------------------------------------------------|
| xs indexOf x  | index of the first element in xs which is equal to x or -1 if x not found |
| xs contains x | does xs contain x?                                                        |
|---------------+---------------------------------------------------------------------------|


** Misc Implementation
#+begin_src scala
    def last[T](xs: List[T]): T = xs match {
        case List()  => throw new Error("last of empty list")
        case List(x) => x
        case y :: ys => last(ys)
      }

     def init[T](xs: List[T]): T = xs match {
        case List()  => throw new Error("init of empty list")
        case List(x) => List()
        case y :: ys => y :: init(ys)
      }

    def concat[T](xs: List[T], ys: List[T]) = xs match {
        case List() => ys
        case x :: zs => x :: concat(zs, ys)
      }

    def reverse[T](xs: List[T]): List[T] = xs match {
        case List() => xs
        case y :: ys => reverse(ys) ++ List(y)
      }
#+end_src

* DONE Pairs and Tuples
CLOSED: [2013-07-24 mer. 09:43]

Merge sort Exercise:

#+begin_src scala
//import scala.util._

object sessionPairTuple {
  def msort(xs: List[Int]): List[Int] = {
    val n = xs.length / 2
      if (n == 0) xs
      else {
        def merge(xs: List[Int], ys: List[Int]): List[Int] = (xs, ys) match {
            case (Nil, ys) => ys
            case (xs, Nil) => xs
            case (x :: xss, y :: yss) => if (x < y) x :: merge(xss, ys)
                                         else       y :: merge(xs, yss)
        }
        val (f, s) = xs splitAt n
        merge(msort(f), msort(s))
      }
  }

  def main(args: Array[String]) = {
    val elems = List(10, 8 , 3, 1, 20)

    println(msort(elems))
  }
}

// [info] Running sessionPairTuple
// List(1, 3, 8, 10, 20)
// [success] Total time: 6 s, completed 24 juil. 2013 09:24:51
#+end_src

* DONE Implicit Parameters
CLOSED: [2013-07-24 mer. 11:11]
** Making msort more generalized
#+begin_src scala
object sessionPairTuple {
  def msort[T](xs: List[T])(lt: (T, T) => Boolean): List[T] = {
    val n = xs.length / 2
      if (n == 0) xs
      else {
        def merge(xs: List[T], ys: List[T]): List[T] = (xs, ys) match {
            case (Nil, ys) => ys
            case (xs, Nil) => xs
            case (x :: xss, y :: yss) => if (lt(x,y)) x :: merge(xss, ys)
                                         else         y :: merge(xs, yss)
        }
        val (f, s) = xs splitAt n
        merge(msort(f)(lt), msort(s)(lt))
      }
  }

  def main(args: Array[String]) = {
    val elems = List(10, 8 , 3, 1, 20)
    println(msort(elems)((x,y) => x < y))

    val fruits = List("apple", "pineapple", "orange", "banana")
    println(msort(fruits)((x,y) => x.compareTo(y) < 0))
  }
}

// [info] Running sessionPairTuple
// List(1, 3, 8, 10, 20)
// List(apple, banana, orange, pineapple)
// [success] Total time: 5 s, completed 24 juil. 2013 09:51:49

#+end_src

** Parametrization with Ordered
#+begin_src scala
import math.Ordering

object sessionPairTuple {
  def msort[T](xs: List[T])(ord: Ordering[T]): List[T] = {
    val n = xs.length / 2
      if (n == 0) xs
      else {
        def merge(xs: List[T], ys: List[T]): List[T] = (xs, ys) match {
            case (Nil, ys) => ys
            case (xs, Nil) => xs
            case (x :: xss, y :: yss) => if (ord.lt(x,y)) x :: merge(xss, ys)
                                         else         y :: merge(xs, yss)
        }
        val (f, s) = xs splitAt n
        merge(msort(f)(ord), msort(s)(ord))
      }
  }

  def main(args: Array[String]) = {
    val elems = List(10, 8 , 3, 1, 20)
    println(msort(elems)(Ordering.Int))

    val fruits = List("apple", "pineapple", "orange", "banana")
    println(msort(fruits)(Ordering.String))
  }
}

// [info] Running sessionPairTuple
// List(1, 3, 8, 10, 20)
// List(apple, banana, orange, pineapple)
// [success] Total time: 5 s, completed 24 juil. 2013 10:36:47

#+end_src

** Implicit parameters
#+begin_src scala
import math.Ordering

object sessionPairTuple {
  def msort[T](xs: List[T])(implicit ord: Ordering[T]): List[T] = {
    val n = xs.length / 2
      if (n == 0) xs
      else {
        def merge(xs: List[T], ys: List[T]): List[T] = (xs, ys) match {
            case (Nil, ys) => ys
            case (xs, Nil) => xs
            case (x :: xss, y :: yss) => if (ord.lt(x,y)) x :: merge(xss, ys)
                                         else         y :: merge(xs, yss)
        }
        val (f, s) = xs splitAt n
        merge(msort(f), msort(s))
      }
  }

  def main(args: Array[String]) = {
    val elems = List(10, 8 , 3, 1, 20)
    println(msort(elems))

    val fruits = List("apple", "pineapple", "orange", "banana")
    println(msort(fruits))
  }
}

// [info] Running sessionPairTuple
// List(1, 3, 8, 10, 20)
// List(apple, banana, orange, pineapple)
// [success] Total time: 5 s, completed 24 juil. 2013 11:07:52

#+end_src

* DONE Higher-Order List Functions
CLOSED: [2013-07-24 mer. 12:20]
** Recurring patterns for computations on Lists
- transforming each elt in a list in a certain way         -> map
- retrieving a list of all elements satisfying a criterion -> filter
- combining the elements of a list using an operator       -> fold/reduce
** Applying a function of elements of a list
map
#+begin_src scala
object sessionHOFList {
  def main(args: Array[String]) = {
    val elems = List(1.0, 1.5, 2.9, 4.5)
    val elemsMap = elems map (x => x * 0.5)

    println(elemsMap)
  }
}

// [info] Running sessionHOFList
// List(0.5, 0.75, 1.45, 2.25)
// [success] Total time: 6 s, completed 24 juil. 2013 11:22:39
#+end_src
** Exercise

Consider a function to square each element of a list, and return the result.
Complete the 2 following equivalent definitions of squareList:

#+begin_src scala
    def squareList(xs: List[Int]): List[Int] = xs match {
      case Nil     => xs
      case y :: ys => y * y :: squareList(ys)
    }

    def mapSquare(xs: List[Int]): List[Int] = xs map (x => x * x)
#+end_src

Output:
#+begin_src scala
// [info] Running sessionHOFList
// List(0.5, 0.75, 1.45, 2.25)
// List(1, 9, 25, 49)
// List(1, 9, 25, 49)
// [success] Total time: 3 s, completed 24 juil. 2013 11:26:25
#+end_src

** Filtering
Select elements that satisfy a predicate
#+begin_src scala
    val nlems = List(-1, 1, 10, -2, 45)
    println(nlems filter (x => x > 0))

// List(1, 10, 45)
#+end_src

** Variations of filter
- filterNot
#+begin_src scala
    val nlems = List(-1, 1, 10, -2, 45)
    println(nlems filter    (x => x > 0))
    println(nlems filterNot (x => x > 0))

// List(1, 10, 45)
// List(-1, -2)
#+end_src

- partition
#+begin_src scala
    println(nlems partition (x => x > 0))

// (List(1, 10, 45),List(-1, -2))
#+end_src

- takeWhile
#+begin_src scala
    println(nlems takeWhile (x => x < 0))

// List(-1)
#+end_src

- dropWhile
#+begin_src scala
    println(nlems dropWhile (x => x < 0))

// List(1, 10, -2, 45)
#+end_src

- span
#+begin_src scala
    println(nlems span      (x => x < 0))

// (List(-1),List(1, 10, -2, 45))
#+end_src


** Exercise
Write a function pack that packs consecutive duplicates of list elements into sublists. For instance:
=pack(List("a", "a", "a", "b", "c", "c", "a"))=

should give:
=List(List("a", "a", "a"), List("b"), List("c", "c"), List("a"))=

#+begin_src scala
    def pack[T](xs: List[T]): List[List[T]] = xs match {
        case Nil     => Nil
        case y :: ys => {
          val (yss, rss) = xs span (x => x == y)
          yss :: pack(rss)
        }
      }

    val listToPack = List("a", "a", "a", "b", "c", "c", "a")
    println(pack(listToPack))

// List(List(a, a, a), List(b), List(c, c), List(a))
#+end_src


** Exercise

Using pack, write a function encode that produces the run-length encoding a list.
The idea is to encode n consecutive duplicates of an element x as a pair (x, n).
For instance,
=encode(List("a", "a", "a", "b", "c", "c", "a"))=
should give
=List(("a", 3), ("b", 1), ("c", 2), ("a", 1))=

#+begin_src scala
    def encode[T](xs: List[T]): List[(T, Int)] = pack(xs) map (x => (x.head, x.length))
    println(encode(listToPack))

// List((a,3), (b,1), (c,2), (a,1))
#+end_src

* DONE Reduction of Lists
CLOSED: [2013-07-24 mer. 13:00]
Another common operation on list is to combine the elements of a list using a given operator -> fold/reduce
** ReduceLeft
#+begin_src scala
object sessionReduceList {
  def main(args: Array[String]) = {
    def sum(xs: List[Int]): Int = (0 :: xs) reduceLeft (_ + _)
    def pdt(xs: List[Int]): Int = (1 :: xs) reduceLeft (_ * _)

    val elems = List(1, 3, 5, 7)
    println(sum(elems))
    println(pdt(elems))
  }
}

// [info] Running sessionReduceList
// 16
// 105
// [success] Total time: 0 s, completed 24 juil. 2013 12:29:44
#+end_src

** FoldLeft
#+begin_src scala
object sessionReduceList {
  def main(args: Array[String]) = {
    def sum(xs: List[Int]): Int = (xs foldLeft 0) (_ + _)
    def pdt(xs: List[Int]): Int = (xs foldLeft 1) (_ * _)

    val elems = List(1, 3, 5, 7)
    println(sum(elems))
    println(pdt(elems))
  }
}

// [info] Running sessionReduceList
// 16
// 105
// [success] Total time: 1 s, completed 24 juil. 2013 12:31:35

#+end_src

** ReduceRight
** FoldRight
** Difference
for operators that are associative or commutative, left and right reduce are equivalent (even with performance difference).

* TODO Reasoning About Concat
* TODO A Larger Equational Proof on Lists
* TODO Functions as Objects
* TODO Objects Everywhere
* TODO Subtyping and Generics
* TODO Variance
* TODO Decomposition
* TODO Pattern Matching
* TODO Lists
* TODO Other Collections
* TODO Combinatorial Search and For-Expressions
* TODO Combinatorial Search Example
* TODO Queries with For
* TODO Translation of For
* TODO Maps
* TODO Putting the Pieces Together
* TODO Structural Induction on Trees
* TODO Streams
* TODO Lazy Evaluation
* TODO Computing with Infinite Sequences
* TODO Case Study the Water Pouring Problem
* TODO Course Conclusion
